// n8n Automation Sidekick - Popup Script
class N8NSidekick {
  constructor() {
    this.currentTab = 'generate';
    this.isGenerating = false;
    this.currentWorkflow = null;
    this.canvasContext = null;
    this.isContextAware = false;
    this.builder = null;
    this.authUser = null;
    this.importAttemptCounter = 0;
    
    this.init();
  }

  async findN8NTabInCurrentWindow() {
    const tabs = await chrome.tabs.query({ currentWindow: true });
    const isN8NUrl = (url = '') => {
      const lowered = String(url).toLowerCase();
      return (
        lowered.includes('n8n.io') ||
        lowered.includes('n8n.cloud') ||
        lowered.includes('app.n8n.cloud') ||
        lowered.includes('localhost:5678') ||
        lowered.includes('127.0.0.1:5678') ||
        /\/workflow(s)?\b/.test(lowered)
      );
    };

    const activeTab = tabs.find(tab => tab.active);
    if (activeTab && isN8NUrl(activeTab.url)) {
      return activeTab;
    }
    return tabs.find(tab => isN8NUrl(tab.url)) || null;
  }

  async initializeExtensionAuth() {
    try {
      if (!window.supabaseExtension?.isInitialized) {
        await window.supabaseExtension?.initialize?.();
      }

      if (!window.supabaseExtension?.isInitialized) {
        this.updateExtensionAuthUI();
        return;
      }

      this.authUser = await window.supabaseExtension.getCurrentUser();

      await window.supabaseExtension.onAuthStateChange((_event, session) => {
        this.authUser = session?.user || null;
        this.updateExtensionAuthUI();
      });
    } catch (error) {
      console.error('Failed to initialize extension auth:', error);
    } finally {
      this.updateExtensionAuthUI();
    }
  }

  updateExtensionAuthUI() {
    const authState = document.getElementById('authState');
    const signedOut = document.getElementById('signedOutState');
    const signedIn = document.getElementById('signedInState');
    const authUserEmail = document.getElementById('authUserEmail');

    if (!authState || !signedOut || !signedIn || !authUserEmail) {
      return;
    }

    if (!window.supabaseExtension?.isInitialized) {
      authState.textContent = 'Auth service unavailable';
      signedOut.style.display = 'none';
      signedIn.style.display = 'none';
      return;
    }

    if (this.authUser?.email) {
      authState.textContent = 'Signed in';
      authUserEmail.textContent = this.authUser.email;
      signedOut.style.display = 'none';
      signedIn.style.display = 'block';
    } else {
      authState.textContent = 'Not signed in';
      signedOut.style.display = 'block';
      signedIn.style.display = 'none';
    }
  }

  async handleAuthSignIn() {
    const email = document.getElementById('authEmail')?.value?.trim();
    const password = document.getElementById('authPassword')?.value || '';
    if (!email || !password) {
      this.showApiStatus('error', 'Enter email and password to sign in');
      return;
    }

    try {
      await window.supabaseExtension.signIn(email, password);
      this.showSuccessMessage('Signed in successfully');
    } catch (error) {
      this.showError(error.message || 'Sign in failed');
    }
  }

  async handleAuthSignUp() {
    const email = document.getElementById('authEmail')?.value?.trim();
    const password = document.getElementById('authPassword')?.value || '';
    if (!email || !password) {
      this.showApiStatus('error', 'Enter email and password to sign up');
      return;
    }

    try {
      await window.supabaseExtension.signUp(email, password);
      this.showSuccessMessage('Account created. Check your email for confirmation.');
    } catch (error) {
      this.showError(error.message || 'Sign up failed');
    }
  }

  async handleAuthSignOut() {
    try {
      await window.supabaseExtension.signOut();
      this.showSuccessMessage('Signed out');
    } catch (error) {
      this.showError(error.message || 'Sign out failed');
    }
  }

  async saveWorkflowToProfile() {
    if (!window.supabaseExtension || !window.supabaseExtension.currentUser) {
      this.showError('Please sign in to save workflows');
      return;
    }
    if (!this.currentWorkflow) {
      this.showError('No workflow to save. Generate one first.');
      return;
    }

    try {
      const workflowStorage = new WorkflowStorage(window.supabaseExtension.getClient());
      const workflowName = prompt('Enter a name for your workflow:', 'Generated Workflow');
      if (!workflowName) return;

      const privacy = confirm('Make this workflow public? (Click OK for public, Cancel for private)');
      const visibility = privacy ? 'public' : 'private';

      const saved = await workflowStorage.saveWorkflow(
        window.supabaseExtension.currentUser.id,
        this.currentWorkflow,
        {
          name: workflowName,
          description: `Generated by AI: ${this.currentPrompt || 'No description'}`,
          visibility,
          tags: this.extractTagsFromWorkflow(this.currentWorkflow)
        }
      );

      this.showSuccessMessage(`Workflow "${saved.name}" saved to your profile (${visibility})`);
      console.log('Saved workflow:', saved);
    } catch (error) {
      console.error('Save workflow failed:', error);
      this.showError('Failed to save workflow');
    }
  }

  extractTagsFromWorkflow(workflow) {
    const tags = new Set();
    if (workflow?.nodes) {
      workflow.nodes.forEach(node => {
        if (node.type) {
          const nodeType = node.type.replace('n8n-nodes-base.', '');
          tags.add(nodeType);
        }
      });
    }
    return Array.from(tags).slice(0, 5); // Limit to 5 tags
  }

  setActionButtonsEnabled(enabled) {
    const copyBtn = document.getElementById('copyBtn');
    const importBtn = document.getElementById('importBtn');

    [copyBtn, importBtn].forEach(btn => {
      if (!btn) return;
      btn.disabled = !enabled;
      btn.style.opacity = enabled ? '1' : '0.6';
      btn.style.cursor = enabled ? 'pointer' : 'not-allowed';
    });
  }

  async init() {
    console.log('=== INITIALIZING EXTENSION ===');
    try {
      await this.initialize();
      console.log('=== EXTENSION INITIALIZED ===');
    } catch (error) {
      console.error('=== INITIALIZATION FAILED ===', error);
    }
  }

  async initialize() {
    try {
      // Load settings
      await this.loadSettings();
      
      // Initialize provider selection
      this.initializeProviderSelection();
      
      // Initialize temperature slider
      this.initializeTemperatureSlider();
      
      // Initialize debug panel
      this.initializeDebugPanel();
      
      // Initialize test suite
      this.initializeTestSuite();
      
      // Initialize tab switching
      this.initializeTabs();
      
      // Setup event listeners (CRITICAL - this was missing!)
      this.setupEventListeners();
      
      // Set default tab
      this.switchTab('generate');
      this.setActionButtonsEnabled(false);
      await this.initializeExtensionAuth();
      
      console.log('Extension initialized successfully');
    } catch (error) {
      console.error('Failed to initialize extension:', error);
    }
  }

  initializeTestSuite() {
    // Make test functions available globally
    if (typeof window.testSuite === 'undefined') {
      console.log('Test suite not loaded, creating fallback functions');
      
      // Fallback functions if test suite isn't loaded
      window.runQuickTest = async () => {
        console.log(' Running Quick Test (fallback)');
        this.showTestResults('Test suite not loaded. Please refresh the extension.');
      };
      
      window.testConnection = async (provider) => {
        console.log(` Testing Connection for ${provider || 'selected'} (fallback)`);
        try {
          const settings = await this.getSettings();
          const testProvider = provider || settings.provider;
          
          let response, data, output;
          
          switch (testProvider) {
            case 'openrouter':
              response = await fetch('https://openrouter.ai/api/v1/models', {
                headers: { 'Authorization': `Bearer ${settings.openrouterApiKey}` }
              });
              data = await response.json();
              output = `OpenRouter connection successful!\n`;
              output += `Available models: ${data.data?.length || 0}\n`;
              break;
              
            case 'openai':
              response = await fetch('https://api.openai.com/v1/models', {
                headers: { 'Authorization': `Bearer ${settings.openaiApiKey}` }
              });
              data = await response.json();
              output = `OpenAI connection successful!\n`;
              output += `Available models: ${data.data?.length || 0}\n`;
              break;
              
            case 'google':
              response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${settings.googleApiKey}`);
              data = await response.json();
              output = `Google Gemini connection successful!\n`;
              output += `Available models: ${data.models?.length || 0}\n`;
              break;
              
            case 'groq':
              response = await fetch('https://api.groq.com/openai/v1/models', {
                headers: { 'Authorization': `Bearer ${settings.groqApiKey}` }
              });
              data = await response.json();
              output = `Groq connection successful!\n`;
              output += `Available models: ${data.data?.length || 0}\n`;
              break;
              
            case 'ollama':
              response = await fetch(`${settings.ollamaUrl}/api/tags`);
              data = await response.json();
              output = `Ollama connection successful!\n`;
              output += `Server: ${settings.ollamaUrl}\n`;
              output += `Available models:\n`;
              data.models.forEach(model => {
                output += `  ‚Ä¢ ${model.name} (${this.formatBytes(model.size)})\n`;
              });
              break;
              
            default:
              throw new Error(`Unsupported provider: ${testProvider}`);
          }
          
          if (response.ok) {
            this.showTestResults(output);
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          const output = `${testProvider} connection failed: ${error.message}`;
          this.showTestResults(output);
        }
      };
      
      window.testPromptGeneration = async () => {
        console.log(' Testing Prompt Generation (fallback)');
        try {
          const settings = await this.getSettings();
          const testPrompt = 'Create a simple workflow: When a webhook receives data, send an email notification';
          
          // Test with the selected provider
          const result = await this.callAI(testPrompt, settings);
          
          if (result && result.nodes && result.nodes.length > 0) {
            const output = `‚úÖ Prompt generation test successful!\n\n`;
            output += `Provider: ${settings.provider}\n`;
            output += `Model: ${settings.provider === 'openrouter' ? settings.model : 
                     settings.provider === 'openai' ? settings.openaiModel :
                     settings.provider === 'google' ? settings.googleModel :
                     settings.provider === 'groq' ? settings.groqModel :
                     settings.provider === 'ollama' ? settings.ollamaModel : 'unknown'}\n`;
            output += `Nodes generated: ${result.nodes.length}\n`;
            output += `Workflow name: ${result.name || 'Unnamed'}\n`;
            output += `Valid JSON: ${!!result.connections ? 'Yes' : 'No'}\n`;
            
            this.showTestResults(output);
          } else {
            throw new Error('No workflow generated');
          }
        } catch (error) {
          const output = `‚ùå Prompt generation test failed: ${error.message}`;
          this.showTestResults(output);
        }
      };
    } else {
      console.log('Test suite loaded successfully');
    }
  }

  showTestResults(output) {
    const resultsDiv = document.getElementById('testResults');
    const outputDiv = document.getElementById('testOutput');
    
    if (resultsDiv && outputDiv) {
      resultsDiv.style.display = 'block';
      outputDiv.textContent = output;
      
      // Add color coding
      outputDiv.innerHTML = output
        .replace(/‚úÖ/g, '<span class="success">‚úÖ</span>')
        .replace(/‚ùå/g, '<span class="error">‚ùå</span>')
        .replace(/üí•/g, '<span class="error">üí•</span>')
        .replace(/üü°/g, '<span class="warning">üü°</span>')
        .replace(/üî¥/g, '<span class="error">üî¥</span>')
        .replace(/üéØ/g, '<span class="info">üéØ</span>');
    } else {
      console.log('Test results divs not found');
    }
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  initializeDebugPanel() {
    // Create debug panel toggle button
    const debugToggle = document.createElement('button');
    debugToggle.innerHTML = '';
    debugToggle.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      width: 30px;
      height: 30px;
      border: 1px solid #ddd;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      font-size: 14px;
      z-index: 10000;
    `;
    
    debugToggle.addEventListener('click', () => {
      if (window.debugSystem) {
        window.debugSystem.togglePanel();
      } else {
        console.log('Debug system not available');
      }
    });
    
    document.body.appendChild(debugToggle);
  }

  initializeTabs() {
    // Add click listeners to tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const tabName = btn.getAttribute('data-tab');
        if (tabName) {
          this.switchTab(tabName);
        }
      });
    });
  }

  initializeProviderSelection() {
    const providerSelect = document.getElementById('providerSelect');
    if (providerSelect) {
      providerSelect.addEventListener('change', (e) => {
        this.switchProvider(e.target.value);
      });
    }
  }

  initializeTemperatureSlider() {
    const temperatureSlider = document.getElementById('temperature');
    const temperatureValue = document.querySelector('.temperature-value');
    
    if (temperatureSlider && temperatureValue) {
      temperatureSlider.addEventListener('input', (e) => {
        temperatureValue.textContent = e.target.value;
      });
    }
  }

  setupEventListeners() {
    console.log('=== SETTING UP EVENT LISTENERS ===');
    
    // Tab navigation
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', (e) => this.switchTab(e.target.dataset.tab));
    });

    // Generate button
    document.getElementById('generateBtn').addEventListener('click', () => this.generateWorkflow());

    // Copy and Import buttons
    document.getElementById('copyBtn').addEventListener('click', () => this.copyToClipboard());
    document.getElementById('importBtn').addEventListener('click', () => this.importToCanvas());

    // Provider selection
    document.getElementById('providerSelect').addEventListener('change', (e) => this.switchProvider(e.target.value));

    // Test connection buttons - add individual listeners for debugging
    const ollamaTestBtn = document.querySelector('#ollamaConfig .test-btn');
    console.log('Ollama test button found during setup:', !!ollamaTestBtn);
    if (ollamaTestBtn) {
      ollamaTestBtn.addEventListener('click', () => {
        console.log('Ollama test button clicked!');
        this.testConnection('ollama');
      });
    }

    const openrouterTestBtn = document.querySelector('#openrouterConfig .test-btn');
    console.log('OpenRouter test button found during setup:', !!openrouterTestBtn);
    if (openrouterTestBtn) {
      openrouterTestBtn.addEventListener('click', () => {
        console.log('OpenRouter test button clicked!');
        this.testConnection('openrouter');
      });
    }

    const openaiTestBtn = document.querySelector('#openaiConfig .test-btn');
    console.log('OpenAI test button found during setup:', !!openaiTestBtn);
    if (openaiTestBtn) {
      openaiTestBtn.addEventListener('click', () => {
        console.log('OpenAI test button clicked!');
        this.testConnection('openai');
      });
    }

    const googleTestBtn = document.querySelector('#googleConfig .test-btn');
    console.log('Google test button found during setup:', !!googleTestBtn);
    if (googleTestBtn) {
      googleTestBtn.addEventListener('click', () => {
        console.log('Google test button clicked!');
        this.testConnection('google');
      });
    }

    const groqTestBtn = document.querySelector('#groqConfig .test-btn');
    console.log('Groq test button found during setup:', !!groqTestBtn);
    if (groqTestBtn) {
      groqTestBtn.addEventListener('click', () => {
        console.log('Groq test button clicked!');
        this.testConnection('groq');
      });
    }

    // Auto-save settings for all inputs
    document.getElementById('providerSelect').addEventListener('change', () => this.saveSettings());
    document.getElementById('openrouterApiKey').addEventListener('input', () => this.saveSettings());
    document.getElementById('modelSelect').addEventListener('change', () => this.saveSettings());
    document.getElementById('openaiApiKey').addEventListener('input', () => this.saveSettings());
    document.getElementById('openaiModel').addEventListener('change', () => this.saveSettings());
    document.getElementById('googleApiKey').addEventListener('input', () => this.saveSettings());
    document.getElementById('googleModel').addEventListener('change', () => this.saveSettings());
    document.getElementById('ollamaUrl').addEventListener('input', () => this.saveSettings());
    document.getElementById('ollamaModel').addEventListener('change', () => this.saveSettings());
    document.getElementById('groqApiKey').addEventListener('input', () => this.saveSettings());
    document.getElementById('groqModel').addEventListener('change', () => this.saveSettings());
    document.getElementById('temperature').addEventListener('input', (e) => {
      document.querySelector('.temperature-value').textContent = e.target.value;
      this.saveSettings();
    });

    // Auto-save textarea content
    document.getElementById('workflow-description').addEventListener('input', () => this.saveUserInput());

    // Supabase auth controls (extension)
    document.getElementById('authSignInBtn')?.addEventListener('click', () => this.handleAuthSignIn());
    document.getElementById('authSignUpBtn')?.addEventListener('click', () => this.handleAuthSignUp());
    document.getElementById('authSignOutBtn')?.addEventListener('click', () => this.handleAuthSignOut());
    document.getElementById('saveWorkflowBtn')?.addEventListener('click', () => this.saveWorkflowToProfile());

    // Template tab event listeners
    document.getElementById('templateSearch')?.addEventListener('input', (e) => this.searchTemplates(e.target.value));
    
    document.querySelectorAll('.category-btn').forEach(btn => {
      btn.addEventListener('click', (e) => this.filterByCategory(e.target.dataset.category));
    });

    // Template fetching buttons
    document.getElementById('fetchOfficialBtn')?.addEventListener('click', () => this.fetchOfficialTemplates());
    document.getElementById('refreshTemplatesBtn')?.addEventListener('click', () => this.refreshTemplates());
    
    console.log('=== EVENT LISTENERS SETUP COMPLETE ===');
  }

  switchTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.tab === tabName);
    });

    // Update tab panes
    document.querySelectorAll('.tab-pane').forEach(pane => {
      pane.classList.toggle('active', pane.id === `${tabName}-tab`);
    });

    this.currentTab = tabName;
  }

  async generateWorkflow() {
    window.debug.info('WORKFLOW_GENERATION', 'Starting workflow generation');
    
    if (this.isGenerating) {
      window.debug.warn('WORKFLOW_GENERATION', 'Already generating, ignoring request');
      return;
    }

    const description = document.getElementById('workflow-description').value.trim();
    if (!description) {
      window.debug.warn('WORKFLOW_GENERATION', 'Empty description provided');
      this.showError('Please describe your workflow first.');
      return;
    }

    window.debug.debug('WORKFLOW_GENERATION', 'Description provided', {
      length: description.length,
      preview: description.substring(0, 100)
    });

    const settings = await this.getSettings();
    window.debug.debug('WORKFLOW_GENERATION', 'Settings loaded', {
      provider: settings.provider,
      model: settings.model,
      hasValidCredentials: this.hasValidCredentials(settings)
    });
    
    if (!this.hasValidCredentials(settings)) {
      window.debug.error('WORKFLOW_GENERATION', 'Invalid credentials', {
        provider: settings.provider,
        missingKeys: this.getMissingCredentials(settings)
      });
      this.showError('Please configure your API credentials in the Setup tab.');
      this.switchTab('setup');
      return;
    }

    this.currentWorkflow = null;
    this.setActionButtonsEnabled(false);
    this.isGenerating = true;
    this.updateGenerateButton(true);
    this.hideError();
    this.hideResult();

    const generationTimer = window.debug.timer('Complete Workflow Generation');

    try {
      this.updateStatus('thinking', 'Generating workflow...');
      window.debug.info('WORKFLOW_GENERATION', 'Starting AI call');
      
      let workflow;
      if (this.isContextAware && this.canvasContext) {
        window.debug.debug('WORKFLOW_GENERATION', 'Using context-aware generation');
        workflow = await this.generateWithContext(description, settings);
      } else {
        window.debug.debug('WORKFLOW_GENERATION', 'Using standard generation');
        workflow = await this.callAI(description, settings);
      }
      
      this.currentWorkflow = workflow;
      this.setActionButtonsEnabled(true);
      
      window.debug.info('WORKFLOW_GENERATION', 'Workflow generated successfully', {
        hasNodes: !!workflow.nodes,
        nodeCount: workflow.nodes?.length || 0,
        hasConnections: !!workflow.connections,
        workflowSize: JSON.stringify(workflow).length
      });
      
      this.displayResult(workflow);
      this.updateStatus('ready', 'Workflow generated');
      
      // Log to Supabase if authenticated
      if (window.supabaseAuth?.isUserAuthenticated()) {
        await window.supabaseBackend?.logWorkflowGeneration({
          prompt: description,
          provider: settings.provider,
          model: settings.model,
          workflow: workflow,
          success: true,
          error: null
        });
      }
      
    } catch (error) {
      const duration = window.debug.end(generationTimer);
      window.debug.error('WORKFLOW_GENERATION', 'Generation failed', {
        error: error.message,
        stack: error.stack,
        duration
      });
      
      this.showError(error.message || 'Failed to generate workflow. Please try again.');
      this.updateStatus('error', 'Generation failed');
      
      // Log error to Supabase if authenticated
      if (window.supabaseAuth?.isUserAuthenticated()) {
        await window.supabaseBackend?.logWorkflowGeneration({
          prompt: description,
          provider: settings.provider,
          model: settings.model,
          workflow: null,
          success: false,
          error: error.message
        });
      }
    } finally {
      window.debug.end(generationTimer);
      this.isGenerating = false;
      this.updateGenerateButton(false);
    }
  }

  getMissingCredentials(settings) {
    const missing = [];
    switch (settings.provider) {
      case 'openrouter':
        if (!settings.openrouterApiKey) missing.push('OpenRouter API Key');
        break;
      case 'openai':
        if (!settings.openaiApiKey) missing.push('OpenAI API Key');
        break;
      case 'google':
        if (!settings.googleApiKey) missing.push('Google API Key');
        break;
      case 'ollama':
        if (!settings.ollamaUrl) missing.push('Ollama URL');
        break;
      case 'groq':
        if (!settings.groqApiKey) missing.push('Groq API Key');
        break;
    }
    return missing;
  }

  switchProvider(provider) {
    // Hide all provider configs
    document.querySelectorAll('.provider-config').forEach(config => {
      config.style.display = 'none';
    });
    
    // Show selected provider config
    const selectedConfig = document.getElementById(`${provider}Config`);
    if (selectedConfig) {
      selectedConfig.style.display = 'block';
    }
    
    this.saveSettings();
  }

  hasValidCredentials(settings) {
    switch (settings.provider) {
      case 'openrouter':
        return settings.openrouterApiKey;
      case 'openai':
        return settings.openaiApiKey;
      case 'google':
        return settings.googleApiKey;
      case 'ollama':
        return settings.ollamaUrl;
      case 'groq':
        return settings.groqApiKey;
      default:
        return false;
    }
  }

  async testConnection(provider) {
    // Ensure debug system is available
    if (!window.debug) {
      console.warn('Debug system not available, using console.log');
      window.debug = {
        info: (cat, msg, data) => console.log(`[${cat}] ${msg}`, data),
        error: (cat, msg, data) => console.error(`[${cat}] ${msg}`, data),
        debug: (cat, msg, data) => console.log(`[${cat}] ${msg}`, data),
        logAPIRequest: (provider, url, method, headers, body) => console.log(`API_REQUEST ${provider} ${method} ${url}`, { headers, body }),
        logAPIResponse: (provider, status, data, duration) => console.log(`API_RESPONSE ${provider} ${status} (${duration}ms)`, data),
        timer: (label) => ({ startTime: performance.now(), label }),
        end: (timer) => `${timer.label}: ${(performance.now() - timer.startTime).toFixed(2)}ms`
      };
    }

    window.debug.info('TEST_CONNECTION', `Starting connection test for ${provider}`);
    
    const settings = await this.getSettings();
    window.debug.debug('TEST_CONNECTION', 'Settings loaded', {
      provider: settings.provider,
      hasApiKey: !!settings[`${provider}ApiKey`],
      apiKeyLength: settings[`${provider}ApiKey`]?.length
    });
    
    const apiStatus = document.getElementById('apiStatus');
    if (!apiStatus) {
      window.debug.error('TEST_CONNECTION', 'API status element not found');
      return;
    }
    
    let testBtn;
    let url, headers, successMessage;

    window.debug.debug('TEST_CONNECTION', `Configuring test for ${provider}`);
    
    switch (provider) {
      case 'openrouter':
        testBtn = document.querySelector('#openrouterConfig .test-btn');
        url = 'https://openrouter.ai/api/v1/models';
        headers = { 'Authorization': `Bearer ${settings.openrouterApiKey}` };
        successMessage = 'OpenRouter connection successful!';
        break;
        
      case 'openai':
        testBtn = document.querySelector('#openaiConfig .test-btn');
        url = 'https://api.openai.com/v1/models';
        headers = { 'Authorization': `Bearer ${settings.openaiApiKey}` };
        successMessage = 'OpenAI connection successful!';
        break;
        
      case 'google':
        testBtn = document.querySelector('#googleConfig .test-btn');
        url = `https://generativelanguage.googleapis.com/v1beta/models?key=${settings.googleApiKey}`;
        headers = {};
        successMessage = 'Google Gemini connection successful!';
        break;
        
      case 'ollama':
        testBtn = document.querySelector('#ollamaConfig .test-btn');
        url = `${settings.ollamaUrl}/api/tags`;
        headers = {};
        successMessage = 'Ollama connection successful!';
        window.debug.debug('TEST_CONNECTION', `Ollama test - URL: ${url}`);
        break;
        
      case 'groq':
        testBtn = document.querySelector('#groqConfig .test-btn');
        url = 'https://api.groq.com/openai/v1/models';
        headers = { 'Authorization': `Bearer ${settings.groqApiKey}` };
        successMessage = 'Groq connection successful!';
        break;
        
      default:
        window.debug.error('TEST_CONNECTION', 'Unknown provider', { provider });
        return;
    }

    if (!testBtn) {
      window.debug.error('TEST_CONNECTION', 'Test button not found', { provider });
      return;
    }

    const originalText = testBtn.textContent;
    testBtn.disabled = true;
    testBtn.textContent = 'Testing...';
    apiStatus.className = 'api-status';
    apiStatus.textContent = 'Testing connection...';

    try {
      window.debug.logAPIRequest(provider, url, 'GET', headers, null);
      
      const timer = window.debug.timer(`${provider} Test Request`);
      const response = await fetch(url, { headers });
      const duration = parseFloat(window.debug.end(timer).split(':')[1].trim());
      
      window.debug.logAPIResponse(provider, response.status, null, duration);

      if (response.ok) {
        const data = await response.json();
        window.debug.info('TEST_CONNECTION', `${provider} test successful`, {
          status: response.status,
          dataKeys: Object.keys(data),
          duration,
          data: data
        });
        
        apiStatus.textContent = successMessage;
        apiStatus.className = 'api-status success';
        await this.saveSettings();
      } else {
        const errorData = await response.json().catch(() => ({}));
        window.debug.error('TEST_CONNECTION', `${provider} test failed`, {
          status: response.status,
          statusText: response.statusText,
          errorData
        });
        
        apiStatus.textContent = errorData.error?.message || `API connection failed (${response.status})`;
        apiStatus.className = 'api-status error';
      }
    } catch (error) {
      window.debug.error('TEST_CONNECTION', `${provider} network error`, error);
      apiStatus.textContent = `Network error: ${error.message}. Make sure the service is running and accessible.`;
      apiStatus.className = 'api-status error';
    } finally {
      testBtn.disabled = false;
      testBtn.textContent = originalText;
    }
  }

  async callAI(description, settings) {
    console.log('=== CALL AI STARTED ===');
    console.log('Provider:', settings.provider);
    console.log('Model:', settings.model);
    
    const generator = window.createRobustWorkflowGenerator();
    
    try {
      let apiKey;
      switch (settings.provider) {
        case 'openrouter':
          apiKey = settings.openrouterApiKey;
          break;
        case 'openai':
          apiKey = settings.openaiApiKey;
          break;
        case 'groq':
          apiKey = settings.groqApiKey;
          break;
        case 'ollama':
          apiKey = null; // Ollama doesn't need API key
          break;
        default:
          throw new Error(`Unsupported provider: ${settings.provider}`);
      }
      
      if (settings.provider !== 'ollama' && !apiKey) {
        throw new Error(`API key required for ${settings.provider}`);
      }
      
      // Get the correct model for the selected provider
      let model;
      switch (settings.provider) {
        case 'openrouter':
          model = settings.model || 'openai/gpt-4o-mini';
          break;
        case 'openai':
          model = settings.openaiModel || 'gpt-4o-mini';
          break;
        case 'google':
          model = settings.googleModel || 'gemini-2.0-flash-exp';
          break;
        case 'groq':
          model = settings.groqModel || 'llama-3.1-8b-instant';
          break;
        case 'ollama':
          model = settings.ollamaModel || 'llama3.2';
          break;
        default:
          model = settings.model || 'openai/gpt-4o-mini';
      }
      
      const result = await generator.generateWorkflow(
        description,
        settings.provider,
        apiKey,
        model
      );
      
      if (!result.success) {
        throw new Error(result.error);
      }
      
      console.log('=== CALL AI SUCCESS ===');
      return result.workflow;
      
    } catch (error) {
      console.error('=== CALL AI FAILED ===');
      console.error('Error:', error);
      throw error;
    }
  }

  async callOpenRouter(prompt, settings) {
    const timer = window.debug.timer('OpenRouter API Call');
    
    try {
      const apiUrl = window.config.getApiUrl('openrouter');
      const modelConfig = window.config.getModelConfig('openrouter');
      
      window.debug.logAPIRequest('OpenRouter', `${apiUrl}/chat/completions`, 'POST', {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${settings.openrouterApiKey?.substring(0, 20)}...`,
        'HTTP-Referer': window.config.get('app.name').toLowerCase().replace(/\s+/g, '-') + '.com',
        'X-Title': window.config.get('app.name')
      }, {
        model: settings.model || modelConfig.default,
        messages: [
          {
            role: 'system',
            content: 'You are an expert n8n workflow automation assistant. Generate valid, import-ready n8n workflow JSON based on user descriptions. Always respond with only the JSON workflow object, no explanations or markdown formatting.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: parseFloat(settings.temperature || modelConfig.temperature),
        max_tokens: parseInt(settings.maxTokens || modelConfig.maxTokens)
      });
      
      const response = await fetch(`${apiUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${settings.openrouterApiKey}`,
          'HTTP-Referer': window.config.get('app.name').toLowerCase().replace(/\s+/g, '-') + '.com',
          'X-Title': window.config.get('app.name')
        },
        body: JSON.stringify({
          model: settings.model || modelConfig.default,
          messages: [
            {
              role: 'system',
              content: 'You are an expert n8n workflow automation assistant. Generate valid, import-ready n8n workflow JSON based on user descriptions. Always respond with only the JSON workflow object, no explanations or markdown formatting.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: parseFloat(settings.temperature || modelConfig.temperature),
          max_tokens: parseInt(settings.maxTokens || modelConfig.maxTokens)
        })
      });

      const duration = window.debug.end(timer);
      
      window.debug.logAPIResponse('OpenRouter', response.status, null, duration);
      
      if (!response.ok) {
        const errorText = await response.text();
        window.debug.error('OpenRouter', 'API Error', {
          status: response.status,
          statusText: response.statusText,
          errorText
        });
        throw new Error(`OpenRouter API Error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      window.debug.debug('OpenRouter', 'Response data', data);
      
      const content = data.choices?.[0]?.message?.content;
      if (!content) {
        window.debug.error('OpenRouter', 'No content in response', data);
        throw new Error('No response content from OpenRouter');
      }
      
      return content;
    } catch (error) {
      window.debug.end(timer);
      window.debug.error('OpenRouter', 'Request failed', error);
      throw error;
    }
  }

  async callOpenAI(prompt, settings) {
    const apiUrl = window.config.getApiUrl('openai');
    const modelConfig = window.config.getModelConfig('openai');
    
    const response = await fetch(`${apiUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: settings.openaiModel || modelConfig.default,
        messages: [
          {
            role: 'system',
            content: 'You are an expert n8n workflow automation assistant. Generate valid, import-ready n8n workflow JSON based on user descriptions. Always respond with only the JSON workflow object, no explanations or markdown formatting.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: parseFloat(settings.temperature || modelConfig.temperature),
        max_tokens: parseInt(settings.maxTokens || modelConfig.maxTokens)
      })
    });

    return await this.handleResponse(response, 'OpenAI');
  }

  async callGoogle(prompt, settings) {
    const apiUrl = window.config.getApiUrl('google');
    const modelConfig = window.config.getModelConfig('google');
    
    const response = await fetch(`${apiUrl}/models/${settings.googleModel || modelConfig.default}:generateContent?key=${settings.googleApiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: `You are an expert n8n workflow automation assistant. Generate valid, import-ready n8n workflow JSON based on user descriptions. Always respond with only the JSON workflow object, no explanations or markdown formatting.\n\nUser request: ${prompt}`
              }
            ]
          }
        ],
        generationConfig: {
          temperature: parseFloat(settings.temperature),
          maxOutputTokens: 4000
        }
      })
    });

    const data = await this.handleResponse(response, 'Google');
    return data; // handleResponse now returns the content directly for Google too
  }

  async callOllama(prompt, settings) {
    const response = await fetch(`${settings.ollamaUrl}/api/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: settings.ollamaModel,
        prompt: `You are an expert n8n workflow automation assistant. Generate valid, import-ready n8n workflow JSON based on user descriptions. Always respond with only the JSON workflow object, no explanations or markdown formatting.

User request: ${prompt}

Generate the workflow now:`,
        stream: false,
        options: {
          temperature: parseFloat(settings.temperature),
          num_predict: 4000
        }
      })
    });

    console.log('Ollama response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Ollama error:', errorText);
      throw new Error(`Ollama API Error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log('Ollama response data:', data);
    
    // Ollama response format - check if response exists
    if (data.response) {
      return data.response;
    } else if (data.content) {
      return data.content;
    } else {
      console.error('Invalid Ollama response format:', data);
      throw new Error('Invalid response format from Ollama');
    }
  }

  async callGroq(prompt, settings) {
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${settings.groqApiKey}`
      },
      body: JSON.stringify({
        model: settings.groqModel,
        messages: [
          {
            role: 'system',
            content: 'You are an expert n8n workflow automation assistant. Generate valid, import-ready n8n workflow JSON based on user descriptions. Always respond with only the JSON workflow object, no explanations or markdown formatting.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: parseFloat(settings.temperature),
        max_tokens: 4000
      })
    });

    return await this.handleResponse(response, 'Groq');
  }

  async handleResponse(response, provider) {
    console.log(`${provider} API Response status:`, response.status);

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`${provider} API Error Response:`, errorText);
      
      let errorData;
      try {
        errorData = JSON.parse(errorText);
      } catch (e) {
        errorData = { raw: errorText };
      }
      
      // Provide more specific error messages
      if (response.status === 401) {
        throw new Error(`Invalid API key for ${provider}. Please check your API key.`);
      } else if (response.status === 403) {
        throw new Error(`Access forbidden for ${provider}. Your API key may not have access to this model or your account needs verification.`);
      } else if (response.status === 429) {
        throw new Error(`Rate limit exceeded for ${provider}. Please try again in a moment.`);
      } else {
        throw new Error(errorData.error?.message || errorData.message || `${provider} API Error: ${response.status} - ${errorText}`);
      }
    }

    const data = await response.json();
    console.log(`${provider} API Response data:`, data);
    
    // Handle different response formats
    let content;
    
    if (provider === 'Ollama') {
      // Ollama has a different response structure
      content = data.response;
    } else if (provider === 'Google') {
      // Google API response format
      if (data.candidates && data.candidates[0] && data.candidates[0].content) {
        content = data.candidates[0].content.parts[0].text;
      }
    } else {
      // OpenAI/OpenRouter/Groq format
      content = data.choices?.[0]?.message?.content;
    }
    
    if (!content) {
      console.error(`No content in ${provider} response:`, data);
      throw new Error(`No response content from ${provider} AI model`);
    }

    return content;
  }

  createPrompt(description, settings) {
    const includeErrorHandling = document.getElementById('include-error-handling').checked;
    const includeLogging = document.getElementById('include-logging').checked;

    let prompt = `You are an expert n8n workflow architect. Create a production-ready n8n workflow for: "${description}"

CRITICAL REQUIREMENTS:
1. Generate ONLY a valid n8n workflow JSON object
2. Use official n8n node naming conventions (e.g., "n8n-nodes-base.webhook", "n8n-nodes-base.httpRequest")
3. Configure ALL necessary node parameters with realistic values
4. Set up proper node connections in the connections object - THIS IS CRITICAL
5. Include node IDs, names, positions, and typeVersion where applicable

WORKFLOW STRUCTURE (FOLLOW EXACTLY):
{
  "name": "Descriptive workflow name",
  "nodes": [
    {
      "parameters": { /* complete configuration */ },
      "id": "unique-node-id",
      "name": "Human-readable node name",
      "type": "n8n-nodes-base.nodeType",
      "typeVersion": 1,
      "position": [x, y]
    }
  ],
  "connections": {
    "sourceNodeId": {
      "main": [
        [
          {
            "node": "targetNodeId",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "1"
}

CONNECTIONS REQUIREMENTS:
- EVERY node (except the last) must connect to the next node
- Use the exact connections format shown above
- Node IDs in connections must match actual node IDs
- Sequential flow: first node ‚Üí second node ‚Üí third node, etc.

NODE SELECTION GUIDELINES:
- Webhook triggers for external events
- HTTP Request for API integrations
- Set/Filter for data manipulation
- Code nodes for custom JavaScript logic
- Slack/Email for notifications
- Google Sheets/Airtable for data storage`;

    if (includeErrorHandling) {
      prompt += `

ERROR HANDLING:
- Add Error Trigger nodes where appropriate
- Include Set nodes to handle error data
- Configure retry logic for HTTP requests
- Add routing for error paths`;
    }

    if (includeLogging) {
      prompt += `

LOGGING & MONITORING:
- Add No-Op nodes for workflow checkpoints
- Include Set nodes to log key data points
- Configure webhook responses for tracking
- Add timing nodes for performance monitoring`;
    }

    prompt += `

BEST PRACTICES:
- Use descriptive node names
- Position nodes logically (left to right flow: [100, 300], [300, 300], [500, 300], etc.)
- Set appropriate timeouts for HTTP requests
- Include data validation where needed
- Configure proper content types and headers

MOST IMPORTANT: Ensure all nodes are properly connected in sequence. The workflow should flow from trigger through all processing nodes to the final action.

Return ONLY the JSON workflow object. No explanations, no markdown formatting, no code blocks.`;

    return prompt;
  }

  validateWorkflow(workflow) {
    if (!workflow || typeof workflow !== 'object') {
      throw new Error('Invalid workflow structure - must be a JSON object');
    }

    // Check required top-level fields
    const requiredFields = ['nodes', 'connections'];
    for (let field of requiredFields) {
      if (!workflow[field]) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    if (!Array.isArray(workflow.nodes)) {
      throw new Error('Workflow must contain a nodes array');
    }

    if (typeof workflow.connections !== 'object') {
      throw new Error('Workflow must contain a connections object');
    }

    if (workflow.nodes.length === 0) {
      throw new Error('Workflow must contain at least one node');
    }

    // Validate each node
    const nodeIds = new Set();
    workflow.nodes.forEach((node, index) => {
      try {
        this.validateNode(node, index);
        if (nodeIds.has(node.id)) {
          throw new Error(`Duplicate node ID: ${node.id}`);
        }
        nodeIds.add(node.id);
      } catch (error) {
        throw new Error(`Node ${index} (${node.name || 'unnamed'}): ${error.message}`);
      }
    });

    // Validate connections reference existing nodes
    this.validateConnections(workflow.connections, nodeIds);

    // Check for at least one trigger node
    const hasTrigger = workflow.nodes.some(node => 
      node.type.includes('webhook') || 
      node.type.includes('cron') || 
      node.type.includes('manualTrigger') ||
      node.type.includes('formTrigger')
    );

    if (!hasTrigger) {
      console.warn('Warning: No trigger node found in workflow');
    }

    return true;
  }

  validateNode(node, index) {
    if (!node.id || typeof node.id !== 'string') {
      throw new Error('Missing or invalid node ID');
    }

    if (!node.name || typeof node.name !== 'string') {
      throw new Error('Missing or invalid node name');
    }

    if (!node.type || typeof node.type !== 'string') {
      throw new Error('Missing or invalid node type');
    }

    // Validate node type format
    if (!node.type.startsWith('n8n-nodes-')) {
      console.warn(`Warning: Node type "${node.type}" may not be a valid n8n node type`);
    }

    // Validate position
    if (!node.position || !Array.isArray(node.position) || node.position.length !== 2) {
      throw new Error('Missing or invalid node position');
    }

    const [x, y] = node.position;
    if (typeof x !== 'number' || typeof y !== 'number') {
      throw new Error('Node position coordinates must be numbers');
    }

    // Validate parameters
    if (node.parameters && typeof node.parameters !== 'object') {
      throw new Error('Node parameters must be an object');
    }

    // Validate typeVersion if present
    if (node.typeVersion && typeof node.typeVersion !== 'number') {
      throw new Error('Node typeVersion must be a number');
    }
  }

  validateConnections(connections, nodeIds) {
    for (let sourceNodeId in connections) {
      if (!nodeIds.has(sourceNodeId)) {
        throw new Error(`Connection references non-existent node: ${sourceNodeId}`);
      }

      const nodeConnections = connections[sourceNodeId];
      if (!nodeConnections.main || !Array.isArray(nodeConnections.main)) {
        continue;
      }

      nodeConnections.main.forEach((outputGroup, groupIndex) => {
        if (!Array.isArray(outputGroup)) {
          throw new Error(`Invalid connection group ${groupIndex} in node ${sourceNodeId}`);
        }

        outputGroup.forEach((connection, connIndex) => {
          if (!connection.node || !nodeIds.has(connection.node)) {
            throw new Error(`Connection ${connIndex} in group ${groupIndex} of node ${sourceNodeId} references non-existent target node`);
          }

          if (typeof connection.type !== 'string') {
            throw new Error(`Connection ${connIndex} missing type`);
          }

          if (typeof connection.index !== 'number') {
            throw new Error(`Connection ${connIndex} missing index`);
          }
        });
      });
    }
  }

  displayResult(workflow) {
    const resultSection = document.getElementById('resultSection');
    const workflowOutput = document.getElementById('workflowResult') || document.getElementById('workflowJson');
    if (!resultSection || !workflowOutput) {
      console.error('Result UI elements missing: #resultSection or #workflowResult/#workflowJson');
      return;
    }

    const deoverlapped = { ...workflow, nodes: this.ensureNonOverlappingPositions(workflow.nodes || []) };
    workflowOutput.textContent = this.serializeWorkflow(deoverlapped);
    this.currentWorkflow = deoverlapped; // store corrected version
    resultSection.classList.remove('hidden');
    resultSection.style.display = 'block';
    this.setActionButtonsEnabled(true);
    
    // Scroll to result
    resultSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  hideResult() {
    const resultSection = document.getElementById('resultSection');
    if (resultSection) {
      resultSection.classList.add('hidden');
      resultSection.style.display = 'none';
    }
    if (!this.currentWorkflow) {
      this.setActionButtonsEnabled(false);
    }
  }

  async copyToClipboard() {
    if (!this.currentWorkflow) {
      this.showError('No workflow to copy. Generate a workflow first.');
      return;
    }

    try {
      let workflowForCopy = this.currentWorkflow;
      const targetTab = await this.findN8NTabInCurrentWindow();
      if (targetTab?.id) {
        workflowForCopy = await this.getPreparedWorkflowForImport(targetTab.id, this.currentWorkflow);
      }
      const finalWorkflow = this.ensureNonOverlappingPositions(workflowForCopy.nodes || []);
      await this.copyWorkflowToClipboard({ ...workflowForCopy, nodes: finalWorkflow });
      this.showSuccessMessage('Workflow copied to clipboard!');
    } catch (error) {
      console.error('Copy failed:', error);
      this.showError('Failed to copy to clipboard');
    }
  }

  async importToCanvas() {
    if (!this.currentWorkflow) {
      this.showError('No workflow to import. Generate a workflow first.');
      return;
    }

    try {
      // Try direct canvas injection first (active tab, then any n8n tab)
      const tabs = await chrome.tabs.query({ currentWindow: true });
      const currentTab = tabs.find(tab => tab.active);

      if (!tabs || tabs.length === 0) {
        throw new Error('No browser tabs found');
      }

      const isN8NUrl = (url = '') => {
        const lowered = String(url).toLowerCase();
        return (
          lowered.includes('n8n.io') ||
          lowered.includes('n8n.cloud') ||
          lowered.includes('app.n8n.cloud') ||
          lowered.includes('localhost:5678') ||
          lowered.includes('127.0.0.1:5678') ||
          /\/workflow(s)?\b/.test(lowered)
        );
      };

      const targetTab = (currentTab && isN8NUrl(currentTab.url))
        ? currentTab
        : tabs.find(tab => isN8NUrl(tab.url));

      if (targetTab && targetTab.id) {
        const workflowForImport = await this.getPreparedWorkflowForImport(targetTab.id, this.currentWorkflow);

        // Try direct injection via content script
        const response = await chrome.tabs.sendMessage(targetTab.id, {
          action: 'injectWorkflow',
          workflow: workflowForImport
        });

        if (response && response.success) {
          if (!targetTab.active) {
            try {
              await chrome.tabs.update(targetTab.id, { active: true });
            } catch (tabFocusError) {
              console.warn('Could not focus n8n tab:', tabFocusError);
            }
          }

          if (response.method === 'clipboard') {
            await this.copyWorkflowToClipboard(workflowForImport);
            this.showImportInstructions();
          } else {
            this.showSuccessMessage(`‚úÖ Workflow injected directly via ${response.method}!`);
          }
        } else {
          throw new Error(response?.error || 'Injection failed');
        }
      } else {
        // No n8n tab found, fall back to clipboard
        await this.copyWorkflowToClipboard(this.currentWorkflow);
        this.showImportInstructions();
      }
    } catch (error) {
      console.error('Import failed:', error);
      // Fall back to clipboard method
      try {
        await this.copyWorkflowToClipboard(this.currentWorkflow);
        this.showImportInstructions();
      } catch (clipboardError) {
        this.showError('Failed to prepare workflow for import');
      }
    }
  }

  serializeWorkflow(workflow) {
    return JSON.stringify(this.normalizeWorkflowForPresentation(workflow), null, 2);
  }

  ensureNonOverlappingPositions(nodes) {
    if (!Array.isArray(nodes) || nodes.length < 2) return nodes || [];

    const parsePos = (node, index) => {
      if (Array.isArray(node?.position) && node.position.length >= 2) {
        return [Number(node.position[0]), Number(node.position[1])];
      }
      return [250 + index * 250, 300];
    };

    const used = new Set();
    const baseX = 250;
    const baseY = 300;
    const colGap = 350; // Increased gap to prevent overlap
    const rowGap = 250; // Increased gap
    const cols = 4; // Fewer columns for more spacing

    console.log('üîß De-overlapping nodes:', nodes.length, 'nodes');

    return nodes.map((node, index) => {
      let [x, y] = parsePos(node, index);
      if (!Number.isFinite(x) || !Number.isFinite(y)) {
        x = baseX + (index % cols) * colGap;
        y = baseY + Math.floor(index / cols) * rowGap;
      }

      // Force grid alignment to prevent any overlap
      const gridX = Math.floor(x / colGap) * colGap;
      const gridY = Math.floor(y / rowGap) * rowGap;
      
      let key = `${gridX}:${gridY}`;
      let attempt = 0;
      
      while (used.has(key) && attempt < 100) {
        attempt += 1;
        const slot = index + attempt;
        x = baseX + (slot % cols) * colGap;
        y = baseY + Math.floor(slot / cols) * rowGap;
        key = `${x}:${y}`;
      }

      used.add(key);
      
      const finalPos = [Math.round(x), Math.round(y)];
      console.log(`üìç Node "${node.name}": [${finalPos[0]}, ${finalPos[1]}]`);
      
      return {
        ...node,
        position: finalPos,
      };
    });
  }

  normalizeWorkflowForPresentation(workflow) {
    if (!workflow || typeof workflow !== 'object') {
      return workflow;
    }

    const normalizedNodes = Array.isArray(workflow.nodes)
      ? workflow.nodes.map((node) => {
          const {
            id,
            name,
            type,
            typeVersion,
            position,
            parameters,
            ...rest
          } = node || {};

          return {
            id,
            name,
            type,
            typeVersion,
            position,
            parameters: parameters || {},
            ...rest,
          };
        })
      : [];

    const collisionSafeNodes = this.ensureNonOverlappingPositions(normalizedNodes);

    const normalizedConnections = {};
    const connectionKeys = Object.keys(workflow.connections || {}).sort((a, b) => a.localeCompare(b));
    connectionKeys.forEach((key) => {
      normalizedConnections[key] = workflow.connections[key];
    });

    return {
      name: workflow.name || 'Generated Workflow',
      nodes: collisionSafeNodes,
      connections: normalizedConnections,
      settings: workflow.settings || { executionOrder: 'v1' },
    };
  }

  async getPreparedWorkflowForImport(tabId, workflow) {
    const clonedWorkflow = JSON.parse(JSON.stringify(workflow));
    if (Array.isArray(clonedWorkflow.nodes)) {
      clonedWorkflow.nodes = this.ensureNonOverlappingPositions(clonedWorkflow.nodes);
    }

    try {
      const response = await chrome.tabs.sendMessage(tabId, { action: 'getCanvasState' });
      const canvasState = response?.data?.data || response?.data || null;
      const existingNodes = canvasState?.workflowData?.nodes;

      if (!Array.isArray(existingNodes) || existingNodes.length === 0) {
        return this.applyFallbackImportOffset(clonedWorkflow);
      }

      const incomingNodes = Array.isArray(clonedWorkflow.nodes) ? clonedWorkflow.nodes : [];
      if (incomingNodes.length === 0) {
        return clonedWorkflow;
      }

      const getPosition = (node) => {
        if (Array.isArray(node?.position) && node.position.length >= 2) {
          return [Number(node.position[0]) || 0, Number(node.position[1]) || 0];
        }
        return [0, 0];
      };

      const existingXs = existingNodes.map((node) => getPosition(node)[0]);
      const incomingXs = incomingNodes.map((node) => getPosition(node)[0]);
      const incomingYs = incomingNodes.map((node) => getPosition(node)[1]);

      const maxExistingX = Math.max(...existingXs);
      const minIncomingX = Math.min(...incomingXs);
      const minIncomingY = Math.min(...incomingYs);

      const horizontalGap = 420;
      const verticalOffset = minIncomingY < 120 ? 180 : 0;
      const shiftX = (maxExistingX + horizontalGap) - minIncomingX;

      clonedWorkflow.nodes = incomingNodes.map((node) => {
        const [x, y] = getPosition(node);
        return {
          ...node,
          position: [
            x + shiftX,
            y + verticalOffset,
          ],
        };
      });

      return clonedWorkflow;
    } catch (error) {
      console.warn('Could not compute import offset from canvas state:', error);
      return this.applyFallbackImportOffset(clonedWorkflow);
    }
  }

  applyFallbackImportOffset(workflow) {
    const nodes = Array.isArray(workflow?.nodes) ? workflow.nodes : [];
    if (nodes.length === 0) return workflow;

    this.importAttemptCounter += 1;
    const shiftX = 420 * this.importAttemptCounter;
    const shiftY = 80 * ((this.importAttemptCounter - 1) % 3);

    workflow.nodes = nodes.map((node) => {
      if (!Array.isArray(node?.position) || node.position.length < 2) {
        return node;
      }
      return {
        ...node,
        position: [
          (Number(node.position[0]) || 0) + shiftX,
          (Number(node.position[1]) || 0) + shiftY,
        ],
      };
    });

    return workflow;
  }

  async copyWorkflowToClipboard(workflow) {
    const payload = this.serializeWorkflow(workflow);
    try {
      await navigator.clipboard.writeText(payload);
      return;
    } catch (clipboardError) {
      // Fallback for restricted clipboard contexts
      const textArea = document.createElement('textarea');
      textArea.value = payload;
      textArea.setAttribute('readonly', '');
      textArea.style.position = 'absolute';
      textArea.style.left = '-9999px';
      document.body.appendChild(textArea);
      textArea.select();
      const copied = document.execCommand('copy');
      document.body.removeChild(textArea);
      if (!copied) {
        throw clipboardError;
      }
    }
  }

  showImportInstructions() {
    const message = `
üéØ Workflow ready for import!

1. Open your n8n canvas
2. Press Ctrl+V (Windows) or Cmd+V (Mac) to paste
3. The workflow will appear on your canvas

The workflow JSON has been copied to your clipboard.
    `.trim();
    
    // Create a temporary notification
    const notification = document.createElement('div');
    notification.className = 'import-notification';
    notification.innerHTML = `
      <div class="notification-content">
        <h4>Ready to Import!</h4>
        <pre>${message}</pre>
        <button class="close-btn">Got it!</button>
      </div>
    `;
    
    // Add styles if not already present
    if (!document.querySelector('#notification-styles')) {
      const style = document.createElement('style');
      style.id = 'notification-styles';
      style.textContent = `
        .import-notification {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
        }
        .notification-content {
          background: white;
          padding: 24px;
          border-radius: 8px;
          max-width: 350px;
          box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }
        .notification-content h4 {
          margin: 0 0 12px 0;
          color: var(--primary-orange);
          font-size: 16px;
        }
        .notification-content pre {
          background: var(--bg-secondary);
          padding: 12px;
          border-radius: 4px;
          font-size: 12px;
          margin: 0 0 16px 0;
          white-space: pre-wrap;
        }
        .close-btn {
          width: 100%;
          padding: 8px;
          background: var(--primary-orange);
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
        }
        .close-btn:hover {
          background: #ff5a47;
        }
      `;
      document.head.appendChild(style);
    }
    
    document.body.appendChild(notification);
    
    // Handle close button
    notification.querySelector('.close-btn').addEventListener('click', () => {
      notification.remove();
    });
    
    // Auto-close after 10 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove();
      }
    }, 10000);
  }

  async testApiConnection() {
    const apiKey = document.getElementById('apiKey').value.trim();
    const apiStatus = document.getElementById('apiStatus');
    const testBtn = document.getElementById('testApiBtn');
    
    if (!apiKey) {
      this.showApiStatus('error', 'Please enter an API key first');
      return;
    }

    testBtn.disabled = true;
    testBtn.textContent = 'Testing...';
    apiStatus.className = 'api-status';

    try {
      const response = await fetch('https://openrouter.ai/api/v1/models', {
        headers: {
          'Authorization': `Bearer ${apiKey}`
        }
      });

      if (response.ok) {
        this.showApiStatus('success', 'API connection successful!');
        await this.saveSettings();
      } else {
        const errorData = await response.json().catch(() => ({}));
        this.showApiStatus('error', errorData.error?.message || 'API connection failed');
      }
    } catch (error) {
      this.showApiStatus('error', 'Network error - please check your connection');
    } finally {
      testBtn.disabled = false;
      testBtn.textContent = 'Test Connection';
    }
  }

  showApiStatus(type, message) {
    const apiStatus = document.getElementById('apiStatus');
    if (!apiStatus) {
      console.error('API status element not found: #apiStatus');
      return;
    }
    apiStatus.textContent = message;
    apiStatus.className = `api-status ${type}`;
  }

  updateGenerateButton(isGenerating) {
    const btn = document.getElementById('generateBtn');
    if (!btn) {
      console.error('Generate button not found!');
      return;
    }
    
    if (isGenerating) {
      btn.disabled = true;
      btn.innerHTML = '<span class="btn-icon">‚è≥</span> Generating...';
    } else {
      btn.disabled = false;
      btn.innerHTML = '<span class="btn-icon">üöÄ</span> Generate Workflow';
    }
  }

  updateStatus(type, text) {
    const statusText = document.querySelector('.status-text');
    const statusDot = document.querySelector('.status-dot');
    if (!statusText || !statusDot) {
      console.error('Status elements not found: .status-text or .status-dot');
      return;
    }
    
    statusText.textContent = text;
    
    // Update dot color
    statusDot.className = 'status-dot';
    switch (type) {
      case 'thinking':
        statusDot.style.background = '#f59e0b';
        break;
      case 'error':
        statusDot.style.background = '#ef4444';
        break;
      case 'ready':
      default:
        statusDot.style.background = '#10b981';
        break;
    }
  }

  showError(message) {
    const errorSection = document.getElementById('errorSection');
    const errorMessage = document.getElementById('errorMessage');
    if (!errorSection || !errorMessage) {
      console.error('Error UI elements missing: #errorSection or #errorMessage');
      return;
    }
    
    errorMessage.textContent = message;
    errorSection.classList.remove('hidden');
    this.hideResult();
  }

  hideError() {
    const errorSection = document.getElementById('errorSection');
    if (errorSection) {
      errorSection.classList.add('hidden');
    }
  }

  showSuccessMessage(message) {
    // Simple success notification
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--success);
      color: white;
      padding: 12px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      z-index: 1000;
      box-shadow: var(--shadow-lg);
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.remove();
    }, 3000);
  }

  async saveSettings() {
    const settings = {
      provider: document.getElementById('providerSelect').value,
      openrouterApiKey: document.getElementById('openrouterApiKey').value,
      model: document.getElementById('modelSelect').value,
      openaiApiKey: document.getElementById('openaiApiKey').value,
      openaiModel: document.getElementById('openaiModel').value,
      googleApiKey: document.getElementById('googleApiKey').value,
      googleModel: document.getElementById('googleModel').value,
      ollamaUrl: document.getElementById('ollamaUrl').value,
      ollamaModel: document.getElementById('ollamaModel').value,
      groqApiKey: document.getElementById('groqApiKey').value,
      groqModel: document.getElementById('groqModel').value,
      temperature: document.getElementById('temperature').value
    };
    
    await chrome.storage.sync.set({ settings });
  }

  async getSettings() {
    const result = await chrome.storage.sync.get(['settings']);
    return {
      provider: 'openrouter',
      openrouterApiKey: '',
      model: 'openai/gpt-4o-mini',
      openaiApiKey: '',
      openaiModel: 'gpt-4o-mini',
      googleApiKey: '',
      googleModel: 'gemini-2.0-flash-exp',
      ollamaUrl: 'http://localhost:11434',
      ollamaModel: 'llama3.2',
      groqApiKey: '',
      groqModel: 'llama-3.1-8b-instant',
      temperature: '0.7',
      ...result.settings
    };
  }

  async loadSettings() {
    const settings = await this.getSettings();
    
    // Load provider selection
    document.getElementById('providerSelect').value = settings.provider;
    
    // Load OpenRouter settings
    document.getElementById('openrouterApiKey').value = settings.openrouterApiKey || '';
    document.getElementById('modelSelect').value = settings.model;
    
    // Load OpenAI settings
    document.getElementById('openaiApiKey').value = settings.openaiApiKey || '';
    document.getElementById('openaiModel').value = settings.openaiModel;
    
    // Load Google settings
    document.getElementById('googleApiKey').value = settings.googleApiKey || '';
    document.getElementById('googleModel').value = settings.googleModel;
    
    // Load Ollama settings
    document.getElementById('ollamaUrl').value = settings.ollamaUrl;
    document.getElementById('ollamaModel').value = settings.ollamaModel;
    
    // Load Groq settings
    document.getElementById('groqApiKey').value = settings.groqApiKey || '';
    document.getElementById('groqModel').value = settings.groqModel;
    
    // Load temperature
    document.getElementById('temperature').value = settings.temperature;
    document.querySelector('.temperature-value').textContent = settings.temperature;
    
    // Show correct provider config
    this.switchProvider(settings.provider);
  }

  async saveUserInput() {
    const userInput = document.getElementById('workflow-description').value;
    await chrome.storage.local.set({ userInput });
  }

  async loadUserInput() {
    const result = await chrome.storage.local.get(['userInput']);
    if (result.userInput) {
      document.getElementById('workflow-description').value = result.userInput;
    }
  }

  updateUI() {
    this.loadUserInput();
    this.updateContextIndicator();
  }

  // Phase 2: Context-Aware Editing Methods
  async checkCanvasContext() {
    try {
      const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
      const currentTab = tabs[0];
      
      if (!currentTab) return;

      // Check if we're on an n8n page
      const isN8NPage = currentTab.url && (
        currentTab.url.includes('n8n.io') || 
        currentTab.url.includes('n8n.cloud') ||
        currentTab.url.includes('app.n8n.cloud')
      );

      if (isN8NPage) {
        // Try to get canvas state
        const response = await chrome.tabs.sendMessage(currentTab.id, { 
          action: 'getCanvasState' 
        }).catch(() => null);

        if (response && response.success) {
          this.canvasContext = response.data;
          this.isContextAware = true;
          this.enableContextualFeatures();
        }
      }
    } catch (error) {
      console.log('Canvas context check failed:', error);
      this.isContextAware = false;
    }
  }

  enableContextualFeatures() {
    // Show contextual UI elements
    const contextualIndicator = document.createElement('div');
    contextualIndicator.className = 'context-indicator';
    contextualIndicator.innerHTML = `
      <span class="context-badge">üéØ Context Mode</span>
      <span class="context-info">Canvas detected - ${this.canvasContext.nodes?.length || 0} nodes</span>
    `;
    
    // Insert after header
    const header = document.querySelector('.header');
    header.insertAdjacentElement('afterend', contextualIndicator);

    // Add contextual options
    this.addContextualOptions();
    
    // Update placeholder text
    const textarea = document.getElementById('workflow-description');
    if (textarea) {
      textarea.placeholder = `e.g., "Add a Slack notification after the Filter node" or "Modify the HTTP Request to include headers"`;
    }
  }

  addContextualOptions() {
    const optionsSection = document.querySelector('.options-section');
    if (!optionsSection || !this.canvasContext) return;

    const contextualOptions = document.createElement('div');
    contextualOptions.className = 'contextual-options';
    contextualOptions.innerHTML = `
      <div class="option-group">
        <label class="checkbox-label">
          <input type="checkbox" id="use-context" checked>
          <span class="checkmark"></span>
          Use current canvas context
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="smart-connections" checked>
          <span class="checkmark"></span>
          Smart node connections
        </label>
      </div>
      <div class="context-summary">
        <p><strong>Current Canvas:</strong></p>
        <div class="node-list">
          ${this.canvasContext.nodes?.slice(0, 5).map(node => 
            `<div class="node-item">${node.name} (${node.type})</div>`
          ).join('') || ''}
          ${this.canvasContext.nodes?.length > 5 ? 
            `<div class="node-item">... and ${this.canvasContext.nodes.length - 5} more</div>` : ''}
        </div>
      </div>
    `;

    optionsSection.insertAdjacentElement('afterend', contextualOptions);

    // Add event listeners
    document.getElementById('use-context')?.addEventListener('change', () => this.saveSettings());
    document.getElementById('smart-connections')?.addEventListener('change', () => this.saveSettings());
  }

  updateContextIndicator() {
    const statusText = document.querySelector('.status-text');
    const statusDot = document.querySelector('.status-dot');
    
    if (this.isContextAware && statusText && statusDot) {
      statusText.textContent = 'Context Ready';
      statusDot.classList.add('context-ready');
    }
  }

  async generateWithContext(description, settings) {
    const useContext = document.getElementById('use-context')?.checked !== false;
    const smartConnections = document.getElementById('smart-connections')?.checked !== false;

    let enhancedPrompt = description;

    if (useContext && this.canvasContext) {
      enhancedPrompt = this.createContextualPrompt(description, this.canvasContext, smartConnections);
    }

    return await this.callAI(enhancedPrompt, settings);
  }

  createContextualPrompt(description, canvasData, smartConnections) {
    let prompt = `Modify or extend the existing n8n workflow based on: "${description}"

Current Workflow Context:
- Existing Nodes: ${canvasData.nodes?.length || 0}
${canvasData.nodes?.map(node => 
  `- ${node.name} (Type: ${node.type}, ID: ${node.id})`
).join('\n') || ''}

${canvasData.connections && Object.keys(canvasData.connections).length > 0 ? 
  `Current Connections: ${JSON.stringify(canvasData.connections, null, 2)}` : ''
}

Requirements:`;

    // Add contextual intelligence
    if (description.toLowerCase().includes('add') && description.toLowerCase().includes('after')) {
      prompt += `
- Parse the "after [node name]" instruction to identify the connection point
- Insert new nodes after the specified node in the workflow
- Maintain existing connections and add new ones appropriately`;
    }

    if (description.toLowerCase().includes('modify') || description.toLowerCase().includes('change')) {
      prompt += `
- Identify which node(s) to modify based on the description
- Update the specified node parameters while preserving other settings
- Maintain existing connections unchanged`;
    }

    if (description.toLowerCase().includes('replace')) {
      prompt += `
- Remove the specified node and replace it with new functionality
- Preserve input connections to the replaced node
- Connect the new node to the same downstream nodes`;
    }

    if (smartConnections) {
      prompt += `
- Automatically determine the best connection points
- Use n8n best practices for node linking
- Ensure logical flow between nodes`;
    }

    prompt += `

Return the complete, updated workflow JSON that includes both existing and new nodes, ready for import.`;

    return prompt;
  }

  // Template Management Methods
  loadTemplates() {
    this.allTemplates = WorkflowTemplates.getTemplates();
    this.currentCategory = 'all';
    this.currentSearch = '';
    this.renderTemplates();
  }

  async fetchOfficialTemplates() {
    console.log('Fetching official n8n templates...');
    
    const fetchBtn = document.getElementById('fetchOfficialBtn');
    const originalText = fetchBtn.textContent;
    
    try {
      fetchBtn.disabled = true;
      fetchBtn.textContent = 'üåê Fetching...';
      
      const officialTemplates = await N8NTemplateFetcher.fetchOfficialTemplates();
      
      // Merge with existing templates
      this.allTemplates = {
        ...this.allTemplates,
        ...officialTemplates
      };
      
      this.renderTemplates();
      this.showSuccessMessage(`Fetched ${Object.keys(officialTemplates).length} official n8n templates!`);
      
    } catch (error) {
      console.error('Error fetching templates:', error);
      this.showError(`Failed to fetch templates: ${error.message}`);
    } finally {
      fetchBtn.disabled = false;
      fetchBtn.textContent = originalText;
    }
  }

  refreshTemplates() {
    console.log('Refreshing templates...');
    this.loadTemplates();
    this.showSuccessMessage('Templates refreshed!');
  }

  renderTemplates() {
    const templatesList = document.getElementById('templatesList');
    if (!templatesList) return;

    let templates = Object.entries(this.allTemplates);

    // Filter by category
    if (this.currentCategory !== 'all') {
      templates = templates.filter(([id, template]) => 
        template.category.toLowerCase() === this.currentCategory
      );
    }

    // Filter by search
    if (this.currentSearch) {
      templates = templates.filter(([id, template]) => {
        const searchLower = this.currentSearch.toLowerCase();
        return (
          template.name.toLowerCase().includes(searchLower) ||
          template.description.toLowerCase().includes(searchLower) ||
          template.tags.some(tag => tag.toLowerCase().includes(searchLower))
        );
      });
    }

    if (templates.length === 0) {
      templatesList.innerHTML = `
        <div class="no-templates">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9 13H15M9 17H15M12 3L2 7V12C2 16.5 4.23 20.68 7.62 23.15L12 24L16.38 23.15C19.77 20.68 22 16.5 22 12V7L12 3Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <p>No templates found</p>
          <p style="font-size: 12px; margin-top: 4px;">Try adjusting your search or category filter</p>
        </div>
      `;
      return;
    }

    templatesList.innerHTML = templates.map(([id, template]) => `
      <div class="template-card ${template.official ? 'official-template' : ''}" data-template-id="${id}">
        <div class="template-header">
          <h4 class="template-title">
            ${template.name}
            ${template.official ? '<span class="official-badge">‚≠ê Official</span>' : ''}
          </h4>
          <span class="template-category">${template.category}</span>
        </div>
        <p class="template-description">${template.description}</p>
        <div class="template-tags">
          ${template.tags.map(tag => `<span class="template-tag">${tag}</span>`).join('')}
        </div>
        <div class="template-actions">
          <button class="template-btn" onclick="sidekick.useTemplate('${id}')">Use Template</button>
          <button class="template-btn secondary" onclick="sidekick.previewTemplate('${id}')">Preview</button>
        </div>
      </div>
    `).join('');
  }

  searchTemplates(query) {
    this.currentSearch = query;
    this.renderTemplates();
  }

  filterByCategory(category) {
    this.currentCategory = category;
    
    // Update category buttons
    document.querySelectorAll('.category-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.category === category);
    });
    
    this.renderTemplates();
  }

  useTemplate(templateId) {
    const template = WorkflowTemplates.getTemplate(templateId);
    if (!template) return;

    this.currentWorkflow = template.template;
    this.displayResult(template.template);
    
    // Switch to generate tab to show the result
    this.switchTab('generate');
    
    this.showSuccessMessage(`Template "${template.name}" loaded!`);
  }

  previewTemplate(templateId) {
    const template = WorkflowTemplates.getTemplate(templateId);
    if (!template) return;

    // Create preview modal
    const modal = document.createElement('div');
    modal.className = 'template-preview-modal';
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h3>${template.name}</h3>
          <button class="close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <p><strong>Category:</strong> ${template.category}</p>
          <p><strong>Description:</strong> ${template.description}</p>
          <p><strong>Tags:</strong> ${template.tags.join(', ')}</p>
          <div class="workflow-preview">
            <h4>Workflow Structure:</h4>
            <pre>${JSON.stringify(template.template, null, 2)}</pre>
          </div>
        </div>
        <div class="modal-footer">
          <button class="template-btn" onclick="sidekick.useTemplate('${templateId}')">Use This Template</button>
          <button class="template-btn secondary close-modal">Close</button>
        </div>
      </div>
    `;

    // Add modal styles
    if (!document.querySelector('#modal-styles')) {
      const style = document.createElement('style');
      style.id = 'modal-styles';
      style.textContent = `
        .template-preview-modal {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
        }
        .modal-content {
          background: white;
          border-radius: 8px;
          max-width: 600px;
          max-height: 80vh;
          width: 90%;
          overflow: hidden;
          box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }
        .modal-header {
          padding: 20px;
          border-bottom: 1px solid var(--border-color);
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .modal-header h3 {
          margin: 0;
          color: var(--text-primary);
        }
        .close-btn {
          background: none;
          border: none;
          font-size: 24px;
          cursor: pointer;
          color: var(--text-muted);
          padding: 0;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .modal-body {
          padding: 20px;
          max-height: 50vh;
          overflow-y: auto;
        }
        .workflow-preview {
          margin-top: 16px;
        }
        .workflow-preview h4 {
          margin-bottom: 8px;
          color: var(--text-primary);
        }
        .workflow-preview pre {
          background: var(--bg-secondary);
          padding: 12px;
          border-radius: 4px;
          font-size: 11px;
          overflow-x: auto;
          max-height: 200px;
          overflow-y: auto;
        }
        .modal-footer {
          padding: 20px;
          border-top: 1px solid var(--border-color);
          display: flex;
          gap: 12px;
          justify-content: flex-end;
        }
      `;
      document.head.appendChild(style);
    }

    document.body.appendChild(modal);

    // Handle close events
    const closeModal = () => modal.remove();
    modal.querySelector('.close-btn').addEventListener('click', closeModal);
    modal.querySelector('.close-modal').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });
  }
}

// Initialize the application
let sidekick; // Global reference for template onclick handlers
document.addEventListener('DOMContentLoaded', () => {
  sidekick = new N8NSidekick();
});
